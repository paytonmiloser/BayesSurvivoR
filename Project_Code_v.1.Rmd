---
title: "Bayes Final Project"
author: "Payton Miloser"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(readxl)
library(writexl)
library(nimble)
library(rstan)
library(bayesplot)
library(ggplot2)
library(dplyr)
library(tidyr)
library(stringr)   
library(posterior)  
```

```{r}
#Load in the data
getwd()
setwd("C:/Users/pmilo/OneDrive/Desktop/iowa state university/Grad School Year 3/Spring 2025/STAT 544 - BAYES/Group Project- Anna & Sabrina & me")

numsheets <- length(excel_sheets("survivoR.xlsx")) 
sheet_names <- excel_sheets("survivoR.xlsx")

# Read each sheet into a list of data frames
df_list <- lapply(sheet_names, function(x) read_excel("survivoR.xlsx", sheet = x))

# Assign each data frame to the global environment using the sheet names
names(df_list) <- sheet_names
list2env(df_list, envir = .GlobalEnv)
```


```{r}
#combine data sets and get variables we need
dat <- read_excel("merged_survivor_data_final.xlsx")
```




Some data manipulation pre-model run
```{r}
castaways <- df_list[["Castaways"]] %>% 
  filter(str_starts(castaway_id, "US"))  # Ensure US-only

# Remove duplicates based on a string column (e.g., 'name')
df_clean <- dat |>
  distinct(version_season, castaway_id, .keep_all = TRUE)

castaways.clean <- castaways |>
   distinct(version_season, castaway_id, .keep_all = TRUE)

advantage.clean <- df_list[["Advantage Details"]] %>% 
  filter(str_starts(version_season, "US"))

advantage.clean.moves <- df_list[["Advantage Movement"]] %>% 
  filter(str_starts(version_season, "US"))



cast_unique <- castaways.clean %>%
  distinct(castaway_id, season, .keep_all = TRUE)

df_clean <- df_clean %>%
  left_join(
    cast_unique %>% select(castaway_id, version_season, result, jury, day),
    by = c("castaway_id", "version_season")
  )






df_clean$winner <- ifelse(df_clean$result=="Sole Survivor",1,0)

df_clean$jury <- ifelse(df_clean$jury =="TRUE",1,0)


df_clean$game_duration <- df_clean$day
table(advantage.clean$advantage_type, advantage.clean$version_season)

df_clean$n_immunitys_possible <- case_when(
  df_clean$version_season < "US11" ~ 0,
  df_clean$version_season %in% c("US11","US12", "US13") ~ 1,
  df_clean$version_season %in% c("US15", "US17", "US18", "US21", "US23", "US27" ) ~ 2,
  df_clean$version_season %in% c("US14", "US16", "US22", "US24", "US25") ~ 3,
  df_clean$version_season %in% c("US19", "US30", "US32") ~ 4,
  df_clean$version_season %in% c("US26", "US29", "US31") ~ 5,
  df_clean$version_season %in% c("US20", "US28", "US48") ~ 6,
  df_clean$version_season %in% "US33" ~ 7,
  df_clean$version_season %in% c("US34", "US46") ~ 8,
  df_clean$version_season %in% c("US37", "US41", "US43") ~ 9,
  df_clean$version_season %in% c("US35", "US36", "US45") ~ 10,
  df_clean$version_season %in% c("US38", "US42", "US44" ) ~ 11,
  df_clean$version_season %in% "US47" ~ 13,
  df_clean$version_season %in% "US39" ~ 14,
  df_clean$version_season %in% "US40" ~ 17,
  TRUE ~ NA_integer_
)

table(advantage.clean.moves$event)
#played 153/230 idols found
table(advantage.clean.moves$version_season, advantage.clean.moves$event=="Played")

tab <- table(
  advantage.clean.moves$version_season,
  advantage.clean.moves$event == "Played"
)

# Convert to data frame
latvar <- as.data.frame.matrix(tab)

latvar$version_season <- rownames(latvar)

# Rearrange columns if needed
latvar <- latvar[, c("version_season", "FALSE", "TRUE")]

# Optionally rename columns for clarity
names(latvar)[2:3] <- c("not_played", "played")

```

```{r}
covars <- data.frame(winner=df_clean$winner, ID=df_clean$castaway_id, Season=df_clean$version_season, gender=df_clean$gender, ethnicity=df_clean$ethnicity, lgbtq=df_clean$lgbt, collar=df_clean$collar, game_duration=df_clean$game_duration, tribe=df_clean$n_tribe, tribe_challenge_wins=df_clean$n_tribal_challenges, individual_challenge_wins=df_clean$n_individual_challenges, times_immunity_won=df_clean$n_immunity_challenges)

write_xlsx(covars, path="Pays_cleaned_covars_NODUP.xlsx")
write_xlsx(latvar, path="latent_variable_dat.xlsx")

table(covars$Season)

```



MCMC
```{r}
# Prepare your data
model_dat_1 <- list(
  N = nrow(covars),
  P = ncol(covars[,2:12]),
  S =  length(unique(covars$Season)),
  y = covars$winner,
  X = as.matrix(covars[,2:12]),
  season = as.integer(factor(covars$Season))
)


# extract:
N      <- model_dat_1$N
P      <- model_dat_1$P
S      <- model_dat_1$S
Xmat   <- model_dat_1$X
season <- model_dat_1$season
y      <- model_dat_1$y
y <- ifelse(is.na(y)==TRUE, 0, y)





y_vec    <- as.numeric(model_dat_1$y)       # 0/1 → double
X_mat    <- as.matrix(model_dat_1$X)        # should already be numeric, but just in case:
X_mat <- data.frame(X_mat)

#Format X_mat into numeric factors etc
X_mat$ID <- as.integer(factor(X_mat$ID))
# Now values run 1,2,3,…, up to J = number of unique players
X_mat$Season <- as.integer(factor(X_mat$Season))
X_mat$gender <- as.integer(factor(X_mat$gender)) #1 = female, #2 = male
X_mat$ethnicity <- as.integer(factor(X_mat$ethnicity))
X_mat$lgbtq <- as.integer(factor(X_mat$lgbtq))
X_mat$collar <- as.integer(factor(X_mat$collar))

X_mat    <- as.matrix(X_mat) 
X_mat    <- matrix(as.numeric(X_mat), nrow = nrow(X_mat), ncol = ncol(X_mat))
season <- as.numeric(model_dat_1$season)  # integer → double

X_mat2 <- data.frame(X_mat)
write_xlsx(X_mat2, path="XXX.xlsx")

```















Updated maybe working code? 9:22 pm
WORKS 9:54 pm
```{r}
# Step 1: Set P correctly
P <- 11  # you confirmed you only have 11 covariates

# Step 2: Ensure X_mat only includes those 11 covariates
# If X_mat is already correct:
X_scaled <- scale(X_mat)  # standardize for numerical stability

# Otherwise, if X_mat might have extra columns, trim it:
# X_scaled <- scale(X_mat[, 1:11])

# Step 3: Model definition
model_code <- nimbleCode({
  beta0 ~ dnorm(-2.5, 1 / 4)
  for (j in 1:P) {
    beta[j] ~ dnorm(0, 1)
  }
  sigma_alpha ~ dunif(0, 1.5)
  
  for (s in 1:S) {
    alpha[s] ~ dnorm(0, sigma_alpha^2)
  }

  for (i in 1:N) {
    eta[i] <- beta0 + inprod(beta[1:P], X[i, 1:P]) + alpha[season[i]]
    eta_clipped[i] <- max(min(eta[i], 20), -20)  # clamp to avoid overflow
    p[i] <- ilogit(eta_clipped[i])
    y[i] ~ dbern(p[i])
  }
})


# Step 6: Build and compile model
Rmodel <- nimbleModel(code = model_code, data = data, constants = constants, inits = inits())
Cmodel <- compileNimble(Rmodel)

# Step 7: MCMC Configuration
conf <- configureMCMC(Rmodel, monitors = c("beta0", "beta", "sigma_alpha", "alpha"), useConjugacy = FALSE)
conf$removeSamplers()

# Custom samplers
conf$addSampler("beta0", type = "slice")

for (j in 1:P) {
  conf$addSampler(paste0("beta[", j, "]"), type = "RW", control = list(scale = 0.3))
}


conf$addSampler("alpha", type = "RW_block", control = list(scale = 0.02))

conf$addSampler("sigma_alpha", type = "RW", control = list(scale = 0.01))

# Step 8: Build and compile MCMC
Rmcmc <- buildMCMC(conf)
Cmcmc <- compileNimble(Rmcmc, project = Rmodel)

# Step 9: Run MCMC
samples <- runMCMC(Cmcmc,
  niter             = 20000,
  nburnin           = 2000,
  nchains           = 4,
  thin              = 1,
  samplesAsCodaMCMC = TRUE,
  setSeed           = TRUE,
)

Rmodel$calculate()
Rmodel$logProb_y


# Step 10: Diagnostics
samples_mcmc <- as.mcmc.list(samples)

# Summary statistics
summary(samples)
effectiveSize(samples)

# Traceplots
traceplot(samples[, "sigma_alpha"])
traceplot(samples[, c("beta0", "beta[1]", "beta[2]", "beta[3]", "beta[4]", "beta[5]", "beta[6]", "beta[7]", "beta[8]", "beta[9]", "beta[10]", "beta[11]")])

```






```{r}
#latvar adjustments - need to be 875 long

covars$total_idols <- case_when(
  covars$Season < "US11" ~ 0,
  covars$Season %in% c("US11", "US12", "US13") ~ 2,
  covars$Season %in% "US27" ~ 4,
  covars$Season %in% c("US15", "US18") ~ 5,
  covars$Season %in% c("US16", "US17", "US22", "US23", "US25") ~ 6,
  covars$Season %in% c("US14", "US21", "US24") ~ 7,
  covars$Season %in% c("US19", "US30") ~ 8,
  covars$Season %in% "US32" ~ 9,
  covars$Season %in% c("US29", "US31") ~ 10,
  covars$Season %in% c("US26", "US48") ~ 11,
  covars$Season %in% "US28" ~ 12,
  covars$Season %in% "US20" ~ 14,
  covars$Season %in% "US34" ~ 15,
  covars$Season %in% "US33" ~ 16,
  covars$Season %in% "US37" ~ 18,
  covars$Season %in% "US46" ~ 19,
  covars$Season %in% "US36" ~ 23,
  covars$Season %in% "US44" ~ 24,
  covars$Season %in% c("US35", "US41") ~ 26,
  covars$Season %in% "US43" ~ 27,
  covars$Season %in% c("US38", "US42", "US45") ~ 28,
  covars$Season %in% c("US39", "US47") ~ 29,
  covars$Season %in% "US40" ~ 46,
  TRUE ~ NA_integer_
)
  
  
  
covars$idols_played <- case_when(
  covars$Season < "US11" ~ 0,
  covars$Season %in% c("US12", "US13", "US15", "US18") ~ 0,
  covars$Season %in% c("US11", "US16", "US17", "US23", "US24", "US32", "US46") ~ 1,
  covars$Season %in% c("US19", "US21", "US25", "US27") ~ 2,
  covars$Season %in% c("US14", "US22", "US29", "US48") ~ 3,
  covars$Season %in% c("US26", "US28", "US30") ~ 4,
  covars$Season %in% c("US31", "US41", "US45") ~ 5,
  covars$Season %in% c("US20", "US34", "US42", "US43") ~ 6,
  covars$Season %in% c("US33", "US36", "US38", "US44") ~ 7,
    covars$Season %in% "US35" ~ 8,
  covars$Season %in% c("US37", "US39", "US40") ~ 9,
  covars$Season %in% "US47" ~ 12,
  TRUE ~ NA_integer_
) 
  
```  














Model 2:
```{r}
# -----------------------------
# Step 1: Prepare constants and data
# -----------------------------

P <- ncol(X)
N <- nrow(X_scaled)
S <- length(unique(X_mat2$X2))

constants2 <- list(
  N = N,
  P = P,
  S = S,
  X = X_scaled,
  season = model_dat_1$season
)

data2 <- list(
  y = y,
  f = covars$total_idols,
  u = covars$idols_played
)

# -----------------------------
# Step 2: Model definition (with clamped logit)
# -----------------------------

model_code2 <- nimbleCode({
  # Priors on fixed effects
  beta0 ~ dnorm(0, 1)
  for (j in 1:P) {
    beta[j] ~ dnorm(0, 1)
  }
  beta_z ~ dnorm(0, 1)

  # Hyperpriors
  tau ~ T(dnorm(0, 1), 0, )
  sigma_z ~ T(dnorm(0, 1), 0, )
  sigma_alpha ~ T(dnorm(0, 1 / 2.5^2), 0, )

  # Season-level effects
  for (s in 1:S) {
    mu_z[s] ~ dnorm(0, 1 / tau^2)
    alpha_raw[s] ~ dnorm(0, 1)
    alpha[s] <- sigma_alpha * alpha_raw[s]
  }

  # Individual-level model
  for (i in 1:N) {
    # latent trait
    z[i] ~ dnorm(mu_z[season[i]], 1 / sigma_z^2)

    # idols found ~ Poisson
    log(lambda[i]) <- delta0 + delta1 * z[i]
    f[i] ~ dpois(lambda[i])

    # idols played ~ Binomial
    logit(pi[i]) <- zeta0 + zeta1 * z[i]
    u[i] ~ dbin(pi[i], f[i])

    # win model with clamped logit
    eta[i] <- beta0 + inprod(beta[1:P], X[i, 1:P]) + beta_z * z[i] + alpha[season[i]]
    eta_clipped[i] <- max(min(eta[i], 20), -20)
    p[i] <- ilogit(eta_clipped[i])
    y[i] ~ dbern(p[i])
  }

  # Priors for idol submodel
  delta0 ~ dnorm(0, 1)
  delta1 ~ dnorm(0, 1)
  zeta0 ~ dnorm(0, 1)
  zeta1 ~ dnorm(0, 1)
})

# -----------------------------
# Step 3: Initial values
# -----------------------------

inits2 <- function() {
  list(
    beta0 = rnorm(1, -2.5, 1),
    beta = rnorm(P, 0, 0.1),
    beta_z = rnorm(1, 0, 0.1),
    delta0 = rnorm(1, 0, 0.1),
    delta1 = rnorm(1, 0, 0.1),
    zeta0 = rnorm(1, 0, 0.1),
    zeta1 = rnorm(1, 0, 0.1),
    tau = runif(1, 0.2, 1),
    sigma_z = runif(1, 0.2, 1),
    sigma_alpha = runif(1, 0.2, 1),
    mu_z = rnorm(S, 0, 0.2),
    alpha_raw = rnorm(S, 0, 0.2),
    z = rnorm(N, 0, 0.2)
  )
}

# -----------------------------
# Step 4: Build and compile model
# -----------------------------

Rmodel2 <- nimbleModel(
  code = model_code2,
  data = data2,
  constants = constants2,
  inits = inits2()
)

Cmodel2 <- compileNimble(Rmodel2)

# -----------------------------
# Step 5: Configure MCMC
# -----------------------------

conf2 <- configureMCMC(Rmodel2, monitors = c("beta0", "beta", "beta_z", "delta0", "delta1", "zeta0", "zeta1", "sigma_alpha", "tau", "sigma_z", "alpha", "mu_z", "z"))

# You can customize samplers here if needed
# conf2$removeSamplers("z")
# conf2$addSampler(target = "z", type = "slice")

Rmcmc2 <- buildMCMC(conf2)
Cmcmc2 <- compileNimble(Rmcmc2, project = Rmodel2)

# -----------------------------
# Step 6: Run MCMC
# -----------------------------

samples2 <- runMCMC(
  Cmcmc2,
  niter = 20000,
  nburnin = 1000,
  nchains = 4,
  thin = 1,
  samplesAsCodaMCMC = TRUE,
  setSeed = TRUE
)

# -----------------------------
# Step 7: Diagnostics
# -----------------------------

summary(samples2)
effectiveSize(samples2)
traceplot(samples2[, c("beta0", "beta[1]", "beta_z", "sigma_alpha")])



```






















































